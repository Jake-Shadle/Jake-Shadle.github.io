<!DOCTYPE html>
<html>

<head>
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <title>
        Cross compiling Windows binaries from Linux
    </title>

    

<link id="slate" class="stylesheet" rel="stylesheet"
    href="https:&#x2F;&#x2F;jake-shadle.github.io&#x2F;slate.css" />


    <!-- This script must follow css -->
    

    

    

    
    

    <noscript>
        <style>
            .navbar-menu {
                display: block;
            }

            .js-only {
                display: none;
            }
        </style>
    </noscript>
    
</head>

<body>
    
    
<!-- START NAV -->


    

<header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-brand">
                
                <a class="navbar-item" href="/">
                    
                    <span>Home</span>
                    
                </a>
                
                <span class="navbar-burger burger" data-target="navbarMenu">
                    <span></span>
                    <span></span>
                    <span></span>
                </span>
            </div>
            <div id="navbarMenu" class="navbar-menu">
                <div class="navbar-end">
                    
                    
                    
                    
                    <a itemprop="url"
                        class="navbar-item "
                        href="https:&#x2F;&#x2F;jake-shadle.github.io&#x2F;categories">
                        <span itemprop="name">Categories
                        </span>
                    </a>
                    
                    
                    
                    <a itemprop="url"
                        class="navbar-item "
                        href="https:&#x2F;&#x2F;jake-shadle.github.io&#x2F;tags">
                        <span itemprop="name">Tags
                        </span>
                    </a>
                    
                    
                    
                    <a itemprop="url"
                        class="navbar-item "
                        href="https:&#x2F;&#x2F;github.com&#x2F;Jake-Shadle">
                        <span itemprop="name">Github
                        </span>
                    </a>
                    
                    
                    
                    <a itemprop="url"
                        class="navbar-item "
                        href="https:&#x2F;&#x2F;twitter.com&#x2F;Ca1ne">
                        <span itemprop="name">Twitter
                        </span>
                    </a>
                    
                    

                    
                </div>
            </div>
        </div>
    </nav>
</header>


    

<!-- END NAV -->
<main>
    <section class="container">
        <div class="columns is-desktop">
            <div class="column is-10-desktop is-offset-1-desktop">
                <article itemscope itemtype="http://schema.org/BlogPosting">
                    <div class="card article">
                        <div class="card-content">
                            
<header>
    <div class="has-text-centered">
        <a href="https://jake-shadle.github.io/xwin/">
            <p class="title article-title">Cross compiling Windows binaries from Linux
            </p>
        </a>
        <div class="tags has-addons level-item">
            <span class="tag is-rounded">2021-08-22</span>
                       
            <span class="tag is-rounded">
<svg class="i-clock" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round"
    stroke-linejoin="round" stroke-width="6.25%">
    <circle cx="16" cy="16" r="14" />
    <path d="M16 8 L16 16 20 20" />
</svg>
<span>&nbsp;27 minute read</span>
</span>
        </div>
    </div>
</header>

                            <div itemprop="articleBody" class="content article-body">
                                
                                <ul>
                                    
                                    <li>
                                        <a href="https://jake-shadle.github.io/xwin/#introduction">Introduction</a>
                                        
                                    </li>
                                    
                                    <li>
                                        <a href="https://jake-shadle.github.io/xwin/#why">Why?</a>
                                        
                                        <ul>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#speed">Speed</a>
                                            </li>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#cost">Cost</a>
                                            </li>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#containers-k8s">Containers + k8s</a>
                                            </li>
                                            
                                        </ul>
                                        
                                    </li>
                                    
                                    <li>
                                        <a href="https://jake-shadle.github.io/xwin/#rejected-strategies">Rejected Strategies</a>
                                        
                                        <ul>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#using-x86-64-pc-windows-gnu">Using x86_64-pc-windows-gnu</a>
                                            </li>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#using-wine-to-run-the-msvc-toolchain">Using wine to run the MSVC toolchain</a>
                                            </li>
                                            
                                        </ul>
                                        
                                    </li>
                                    
                                    <li>
                                        <a href="https://jake-shadle.github.io/xwin/#how">How?</a>
                                        
                                        <ul>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#prerequisites">Prerequisites</a>
                                            </li>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#1-setup-toolchain-s">1. Setup toolchain(s)</a>
                                            </li>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#2-acquire-rust-std-lib">2. Acquire Rust std lib</a>
                                            </li>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#3-acquire-crt-and-windows-10-sdk">3. Acquire CRT and Windows 10 SDK</a>
                                            </li>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#4-override-cc-defaults">4. Override cc defaults</a>
                                            </li>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#5-profit">5. Profit</a>
                                            </li>
                                            
                                        </ul>
                                        
                                    </li>
                                    
                                    <li>
                                        <a href="https://jake-shadle.github.io/xwin/#bonus-headless-testing">Bonus: Headless testing</a>
                                        
                                        <ul>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#1-install">1. Install</a>
                                            </li>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#2-specify-runner">2. Specify runner</a>
                                            </li>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#3-test">3. Test</a>
                                            </li>
                                            
                                        </ul>
                                        
                                    </li>
                                    
                                    <li>
                                        <a href="https://jake-shadle.github.io/xwin/#final-image-definition">Final image definition</a>
                                        
                                    </li>
                                    
                                    <li>
                                        <a href="https://jake-shadle.github.io/xwin/#common-issues">Common issues</a>
                                        
                                        <ul>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#cmake">CMake</a>
                                            </li>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#masm">MASM</a>
                                            </li>
                                            
                                            <li>
                                                <a href="https://jake-shadle.github.io/xwin/#compiler-target-confusion">Compiler Target Confusion</a>
                                            </li>
                                            
                                        </ul>
                                        
                                    </li>
                                    
                                    <li>
                                        <a href="https://jake-shadle.github.io/xwin/#conclusion">Conclusion</a>
                                        
                                    </li>
                                    
                                </ul>
                                
                                <!-- markdownlint-disable MD033 -->
<h2 id="introduction">Introduction</h2>
<p>Last November I added a new job to our CI to cross compile our project for <code>x86_64-pc-windows-msvc</code> from an <code>x86_64-unknown-linux-gnu</code> host. I had wanted to blog about that at the time but never got around to it, but after making some changes and improvements last month to this, in addition to writing a new utility, I figured now was as good of a time as any to share some knowledge in this area for those who might be interested.</p>
<h2 id="why">Why?</h2>
<p>Before we get started with the <a href="https://jake-shadle.github.io/xwin/#how">How</a>, I want to talk about why one might want to do this in the first place, as natively targeting Windows is a &quot;known quantity&quot; with the least amount of surprise. While there are reasons beyond the following, my primary use case for why I want to do cross compilation to Windows is our <a href="https://en.wikipedia.org/wiki/Continuous_delivery">Continuous Delivery</a> pipeline for my main project at <a href="https://www.embark.dev/">Embark</a>.</p>
<h3 id="speed">Speed</h3>
<p>It's fairly common knowledge that, generally speaking, Linux is faster than Windows on equivalent hardware. From faster <a href="https://github.com/Microsoft/WSL/issues/873#issuecomment-425272829">file I/O</a> to better utilization of high core count machines, and faster process and thread creation, many operations done in a typical CI job such as compilation and linking tend to be faster on Linux. And since I am lazy, I'll let another blog post about cross compiling <a href="https://glandium.org/blog/?p=4020">Firefox from Linux to Windows</a> actually present some numbers in defense of this assertion.</p>
<h3 id="cost">Cost</h3>
<p>Though we're now running a Windows VM in our on-premise data center for our normal Windows CD jobs, we actually used to run it in <a href="https://cloud.google.com/">GCP</a>. It was <strong>1</strong> VM with a modest 32 CPU count, but the licensing costs (Windows Server is <a href="https://www.microsoft.com/en-us/windows-server/pricing">licensed by core</a>) alone accounted for <strong>&gt;20%</strong> of our total costs for this particular GCP project.</p>
<p align="center"><img src="graph_of_sadness.png"/></p>
<p>While this single VM is not a huge deal relative to the total costs of our project, it's still a budget item that provides no substantive value, and on principle I'd rather have more/better CPUs, RAM, disk, or GPUs, that provide immediate concrete value in our CI, or just for local development.</p>
<h3 id="containers-k8s">Containers + k8s</h3>
<p>This one is probably the most subjective, so strap in!</p>
<p>While fast CI is a high priority, it really doesn't matter how fast it is if it gives unreliable results. Since I am the (mostly) sole maintainer, (which yes, we're trying to fix) for our CD pipeline in a team of almost 40 people, my goal early on was to get it into a reliably working state that I could easily maintain with a minimal amount of my time, since I have other, more fun, things to do.</p>
<p>The primary way I did this was to build <a href="https://github.com/EmbarkStudios/buildkite-jobify">buildkite-jobify</a> (we use <a href="https://buildkite.com/features">Buildkite</a> as our CI provider). This is just a small service that spawns <a href="https://kubernetes.io/">Kubernetes (k8s)</a> <a href="https://kubernetes.io/docs/concepts/workloads/controllers/job/">jobs</a> for each of the CI jobs we run on Linux, based on configuration from the repo itself.</p>
<p>This has a few advantages and disadvantages over a more typical VM approach, which we use for <code>x86_64-pc-windows-msvc</code> (for now?), <code>x86_64-apple-darwin</code>, and <code>aarch64-apple-darwin</code>.</p>
<h4 id="pros">Pros</h4>
<ul>
<li>Consistency - Every job run from the same container image has the exact same starting environment.</li>
<li>Versioned - The image definitions are part of our monorepo, as well as the k8s job descriptions, so we get atomic updates of the environment CI jobs execute in with the code itself. This also makes rollbacks trivial if needed.</li>
<li>Scalability - Scaling a k8s cluster up or down is fairly easily (especially in eg <a href="https://cloud.google.com/kubernetes-engine">GKE</a>, because $) as long as you have the compute resources. k8s also makes it easy to specify resource requests so that individual jobs can dynamically spin up on the most appropriate node at the time based on the other workloads currently running on the cluster.</li>
<li>Movability - Since k8s is just running containers, it's trivial to move build jobs between different clusters, for example in our case, from GKE to our on-premise cluster.</li>
</ul>
<h4 id="cons">Cons</h4>
<ul>
<li>Clean builds - Clean builds are quite slow compared to incremental builds, however we mitigate this by using <a href="https://github.com/EmbarkStudios/cargo-fetcher">cargo-fetcher</a> for faster crate fetching and <a href="https://github.com/mozilla/sccache">sccache</a> for compiler output caching.</li>
<li>Startup times - Changing the image used for a build job means that every k8s node that runs an image it doesn't have needs to pull it before running. For example, the pull can take up to almost 2m for our <code>aarch64-linux-android</code> which is by far our largest image at almost 3GiB (the Android NDK/SDK are incredibly bloated). However, this is generally a one time cost per image per node and we don't update images so often that it is actually a problem in practice.</li>
</ul>
<h2 id="rejected-strategies">Rejected Strategies</h2>
<p>Before we get into the how I just wanted to show two other strategies that could be used for cross compilation that you might want to consider if your needs are different than ours.</p>
<h3 id="using-x86-64-pc-windows-gnu">Using <code>x86_64-pc-windows-gnu</code></h3>
<p>To be honest, I rejected this one pretty much immediately simply because the <code>gnu</code> environment is not the &quot;native&quot; <code>msvc</code> environment for Windows. Targeting <code>x86_64-pc-windows-gnu</code> would not be representative for actual builds used by users, and it would be different from the local builds built by developers on Windows, which made it an unappealing option. That being said, generally speaking, Rust crates tend to support <code>x86_64-pc-windows-gnu</code> fairly well, which as we'll see later is a good thing due to my chosen strategy.</p>
<h3 id="using-wine-to-run-the-msvc-toolchain">Using wine to run the MSVC toolchain</h3>
<p>I briefly considered using <a href="https://www.winehq.org/">wine</a> to run the various components of the MSVC compiler toolchain, as that would be the most accurate way to match the native compilation for <code>x86_64-pc-windows-msvc</code>. However, we already use LLD when linking on Windows since it is vastly faster than the MSVC linker, so why not just replace the rest of the toolchain while we're at it? ðŸ˜‰ This kind of contradicts the reasons stated in <a href="https://jake-shadle.github.io/xwin/#using-x86-64-pc-windows-gnu"><code>x86_64-pc-windows-gnu</code></a> since we'd be changing to a completely different compiler with different codegen, but this tradeoff is actually ok with me for a couple of reasons.</p>
<p>The first reason is that the driving force behind <code>clang-cl</code>, <code>lld-link</code>, and the other parts of LLVM replacing the MSVC toolchain, is so that <a href="https://blog.llvm.org/2018/03/clang-is-now-used-to-build-chrome-for.html">Chrome</a> can be built with LLVM for all of their target platforms. The size of the Chrome project dwarfs the amount of C/C++ code in our project by a huge margin, and (I assume) includes far more...advanced...C++ code than we depend on, so the risk of miscompilation or other issues compared to cl.exe seems reasonably low.</p>
<p>And secondly, we're actively trying to get rid of C/C++ dependencies as the Rust ecosystem matures and provides its own versions of C/C++ libraries we use. For example, at the time of this writing, we use roughly 800k lines of C/C++ code, a large portion of which comes from <a href="https://github.com/EmbarkStudios/physx-rs">physx</a>, which we will, hopefully, be able to replace in the future with something like <a href="https://rapier.rs/">rapier</a>.</p>
<h2 id="how">How?</h2>
<p>Ok, now that I've laid out some reasons why you might want to consider cross compilation to Windows from Linux, let's see how we can actually do it! I'll be constructing a container image (in Dockerfile format) as we go that can be used to compile a Rust program. If you're only targeting C/C++ the broad strokes of this strategy will still be relevant, you'll just have a tougher time of it because...well, C/C++.</p>
<p>The strategy I chose is to use clang, which, like most compilers based off of LLVM (including rustc), is a native cross compiler, to compile any C/C++ code and assembly. Specifically this means using <a href="https://clang.llvm.org/docs/MSVCCompatibility.html"><code>clang-cl</code></a> and <a href="https://lld.llvm.org/windows_support.html"><code>lld-link</code></a> so that we, generally, don't need to modify any C/C++ code to take cross compilation into account.</p>
<h3 id="prerequisites">Prerequisites</h3>
<p>If you want to follow along at home, you'll need to be on Linux (though WSL <em>might</em> work?) with something that can build container images, like <a href="https://docs.docker.com/get-docker/"><code>docker</code></a> or <a href="https://podman.io/getting-started/installation"><code>podman</code></a>.</p>
<h3 id="1-setup-toolchain-s">1. Setup toolchain(s)</h3>
<p>First thing we need are the actual toolchains needed to compile and link a full Rust project.</p>
<pre style="background-color:#282c34;">
<code class="language-dockerfile" data-lang="dockerfile"><span style="color:#5c6370;"># We&#39;ll just use the official Rust image rather than build our own from scratch
</span><span style="color:#c678dd;">FROM</span><span style="color:#dcdfe4;"> docker.io/library/rust:1.54.0-slim-bullseye

</span><span style="color:#c678dd;">ENV </span><span style="color:#dcdfe4;">KEYRINGS /usr/local/share/keyrings

</span><span style="color:#c678dd;">RUN </span><span style="color:#dcdfe4;">set -eux; \
    mkdir -p $KEYRINGS; \
    apt-get update &amp;&amp; apt-get install -y gpg curl; \
    </span><span style="color:#5c6370;"># clang/lld/llvm
</span><span style="color:#dcdfe4;">    curl --fail https://apt.llvm.org/llvm-snapshot.gpg.key | gpg --dearmor &gt; $KEYRINGS/llvm.gpg; \
    echo &quot;deb [signed-by=$KEYRINGS/llvm.gpg] http://apt.llvm.org/bullseye/ llvm-toolchain-bullseye-13 main&quot; &gt; /etc/apt/sources.list.d/llvm.list;

</span><span style="color:#c678dd;">RUN </span><span style="color:#dcdfe4;">set -eux; \
    </span><span style="color:#5c6370;"># Skipping all of the &quot;recommended&quot; cruft reduces total images size by ~300MiB
</span><span style="color:#dcdfe4;">    apt-get update &amp;&amp; apt-get install --no-install-recommends -y \
        clang-13 \
        </span><span style="color:#5c6370;"># llvm-ar
</span><span style="color:#dcdfe4;">        llvm-13 \
        lld-13 \
        </span><span style="color:#5c6370;"># We&#39;re using this in step 3
</span><span style="color:#dcdfe4;">        tar; \
    </span><span style="color:#5c6370;"># ensure that clang/clang++ are callable directly
</span><span style="color:#dcdfe4;">    ln -s clang-13 /usr/bin/clang &amp;&amp; ln -s clang /usr/bin/clang++ &amp;&amp; ln -s lld-13 /usr/bin/ld.lld; \
    </span><span style="color:#5c6370;"># We also need to setup symlinks ourselves for the MSVC shims because they aren&#39;t in the debian packages
</span><span style="color:#dcdfe4;">    ln -s clang-13 /usr/bin/clang-cl &amp;&amp; ln -s llvm-ar-13 /usr/bin/llvm-lib &amp;&amp; ln -s lld-link-13 /usr/bin/lld-link; \
    </span><span style="color:#5c6370;"># Verify the symlinks are correct
</span><span style="color:#dcdfe4;">    clang++ -v; \
    ld.lld -v; \
    </span><span style="color:#5c6370;"># Doesn&#39;t have an actual -v/--version flag, but it still exits with 0
</span><span style="color:#dcdfe4;">    llvm-lib -v; \
    clang-cl -v; \
    lld-link --version; \
    </span><span style="color:#5c6370;"># Use clang instead of gcc when compiling binaries targeting the host (eg proc macros, build files)
</span><span style="color:#dcdfe4;">    update-alternatives --install /usr/bin/cc cc /usr/bin/clang 100; \
    update-alternatives --install /usr/bin/c++ c++ /usr/bin/clang++ 100; \
    apt-get remove -y --auto-remove; \
    rm -rf /var/lib/apt/lists/*;
</span></code></pre><h3 id="2-acquire-rust-std-lib">2. Acquire Rust std lib</h3>
<p>By default, <a href="https://github.com/rust-lang/rustup">rustup</a> only installs the native host target of <code>x86_64-unknown-linux-gnu</code>, which we still need to compile <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build scripts</a> and <a href="https://doc.rust-lang.org/reference/procedural-macros.html">procedural macros</a>, but since we're cross compiling we need to add the <code>x86_64-pc-windows-msvc</code> target as well to get the Rust std library. We could also build the standard library ourselves, but that would mean requiring nightly and taking time to compile something that we can just download instead.</p>
<pre style="background-color:#282c34;">
<code class="language-dockerfile" data-lang="dockerfile"><span style="color:#5c6370;"># Retrieve the std lib for the target
</span><span style="color:#dcdfe4;">RUN rustup target add x86_64-pc-windows-msvc
</span></code></pre><h3 id="3-acquire-crt-and-windows-10-sdk">3. Acquire CRT and Windows 10 SDK</h3>
<p>In all likelihood, you'll need the <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-library-features?view=msvc-160">MSVCRT</a> and <a href="https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk/">Windows 10 SDK</a> to compile and link most projects that target Windows. This is problematic because the official way to install them is, frankly, atrocious, in addition to not being redistributable (so no one but Microsoft can provide, say, a tarball with the needed files).</p>
<p>But really, our needs are relatively simple compared to a normal developer on Windows, as we just need the headers and libraries from the typical VS installation. We could if we wanted use the <a href="https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2019">Visual Studio Build Tools</a> from a Windows machine, or if we were feeling adventurous try to get it running under wine (warning: I briefly tried this but it requires .NET shenanigans that at the time were broken under wine) and then create our own tarball with the needed files, but that feels too slow and tedious.</p>
<p>So instead, I just took inspiration from <a href="https://github.com/mstorsjo/msvc-wine">other projects</a> and created my own <a href="https://github.com/Jake-Shadle/xwin"><code>xwin</code></a> program to download, decompress, and repackage the MSVCRT and Windows SDK into a form appropriate for cross compilation. This has several advantages over using the official installation methods.</p>
<ul>
<li>No cruft - Since this program is tailored specifically to getting only the files needed for compiling and linking we skip a ton of cruft, some of which you can opt out of, but some of which you <em>cannot</em> with the official installers. For example, even if you never target <code>aarch64-pc-windows-msvc</code>, you will still get all of the libraries needed for it.</li>
<li>Faster - In addition to not even downloading stuff we don't need, all download, decompression, and disk writes are done in parallel. On my home machine with ~11.7MiB download speeds and a Ryzen 3900X I can download, decompress, and &quot;install&quot; the MSVCRT and Windows SDK in about 27 seconds.</li>
<li>Fixups - While the CRT is generally fine, the Windows SDK headers and libraries are an absolute mess of casing (seriously, what maniac thought it would be a good idea to capitalize the <code>l</code> in <code>.lib</code>!?), making them fairly useless on a case-sensitive file system. Rather than rely on using a case-insensitive file system on Linux, <code>xwin</code> just adds symlinks as needed, so eg. <code>windows.h</code> -&gt; <code>Windows.h</code>, <code>kernel32.lib</code> -&gt; <code>kernel32.Lib</code> etc.</li>
</ul>
<p>We have two basic options for how we could get the CRT and SDK, either run <code>xwin</code> directly during image building, or run it separately and tarball the files and upload them to something like <a href="https://cloud.google.com/storage">GCS</a> and just retrieve them as needed in the future. We'll just use it directly while building the image since that's easier.</p>
<pre style="background-color:#282c34;">
<code class="language-dockerfile" data-lang="dockerfile"><span style="color:#dcdfe4;">RUN set -eux; \
    xwin_version=&quot;0.1.1&quot;; \
    xwin_prefix=&quot;xwin-$xwin_version-x86_64-unknown-linux-musl&quot;; \
    </span><span style="color:#5c6370;"># Install xwin to cargo/bin via github release. Note you could also just use `cargo install xwin`.
</span><span style="color:#dcdfe4;">    curl --fail -L https://github.com/Jake-Shadle/xwin/releases/download/$xwin_version/$xwin_prefix.tar.gz | tar -xzv -C /usr/local/cargo/bin --strip-components=1 $xwin_prefix/xwin; \
    </span><span style="color:#5c6370;"># Splat the CRT and SDK files to /xwin/crt and /xwin/sdk respectively
</span><span style="color:#dcdfe4;">    xwin --accept-license 1 splat --output /xwin; \
    </span><span style="color:#5c6370;"># Remove unneeded files to reduce image size
</span><span style="color:#dcdfe4;">    rm -rf .xwin-cache /usr/local/cargo/bin/xwin;
</span></code></pre><h3 id="4-override-cc-defaults">4. Override <a href="https://github.com/alexcrichton/cc-rs"><code>cc</code></a> defaults</h3>
<p><code>cc</code> is the Rust ecosystem's primary (we'll get to the most common exception <a href="https://jake-shadle.github.io/xwin/#cmake">later</a>) way to compile C/C++ code for use in Rust crates. By default it will try and use <code>cl.exe</code> and friends when targeting the <code>msvc</code> environment, but since we don't have that, we need to inform it what we actually want it to use instead. We also need to provide additional compiler options to <code>clang-cl</code> to avoid common problems when compiling code that assumes that targeting <code>x86_64-pc-windows-msvc</code> can only be done with the MSVC toolchain.</p>
<p>We also need to tell lld where to search for libraries. We <em>could</em> place the libs in one of the default lib directories lld will search in, but that would mean changing the layout of the CRT and SDK library directories, so it's generally easier to just specify them explicitly instead. We use <code>RUSTFLAGS</code> for this, which does mean that if you are specifying things like <code>-Ctarget-feature=+crt-static</code> in <a href="https://doc.rust-lang.org/cargo/reference/config.html">.cargo/config.toml</a> you will need to reapply them in the container image either during image build or by overriding the environment at runtime to get everything working.</p>
<pre style="background-color:#282c34;">
<code class="language-dockerfile" data-lang="dockerfile"><span style="color:#5c6370;"># Note that we&#39;re using the full target triple for each variable instead of the
# simple CC/CXX/AR shorthands to avoid issues when compiling any C/C++ code for
# build dependencies that need to compile and execute in the host environment
</span><span style="color:#dcdfe4;">ENV CC_x86_64_pc_windows_msvc=&quot;clang-cl&quot; \
    CXX_x86_64_pc_windows_msvc=&quot;clang-cl&quot; \
    AR_x86_64_pc_windows_msvc=&quot;llvm-lib&quot; \
    </span><span style="color:#5c6370;"># Note that we only disable unused-command-line-argument here since clang-cl
    # doesn&#39;t implement all of the options supported by cl, but the ones it doesn&#39;t
    # are _generally_ not interesting.
</span><span style="color:#dcdfe4;">    CL_FLAGS=&quot;-Wno-unused-command-line-argument -fuse-ld=lld-link /imsvc/xwin/crt/include /imsvc/xwin/sdk/include/ucrt /imsvc/xwin/sdk/include/um /imsvc/xwin/sdk/include/shared&quot; \
    RUSTFLAGS=&quot;-Lnative=/xwin/crt/lib/x86_64 -Lnative=/xwin/sdk/lib/um/x86_64 -Lnative=/xwin/sdk/lib/ucrt/x86_64&quot;

</span><span style="color:#5c6370;"># These are separate since docker/podman won&#39;t transform environment variables defined in the same ENV block
</span><span style="color:#dcdfe4;">ENV CFLAGS_x86_64_pc_windows_msvc=&quot;$CL_FLAGS&quot; \
    CXXFLAGS_x86_64_pc_windows_msvc=&quot;$CL_FLAGS&quot;
</span></code></pre>
<p>As already noted above in the reasons why we went <a href="https://jake-shadle.github.io/xwin/#how">this route</a>, we use <code>lld-link</code> even when compiling on Windows hosts due to its superior speed over <code>link.exe</code>. So for our project we just set it in our <a href="https://doc.rust-lang.org/cargo/reference/config.html#targettriplelinker">.cargo/config.toml</a> so it's used regardless of host platform.</p>
<pre style="background-color:#282c34;">
<code class="language-ini" data-lang="ini"><span style="color:#c678dd;">[target.x86_64-pc-windows-msvc]
</span><span style="color:#e06c75;">linker </span><span style="color:#c678dd;">= </span><span style="color:#98c379;">&quot;lld-link&quot; </span><span style="color:#5c6370;"># Note the lack of extension, which means it will work on both Windows and unix style platforms
</span></code></pre>
<p>If you don't already use <code>lld-link</code> when targeting Windows, you'll need to add an additional environment variable so that cargo knows what linker to use, otherwise it will default to <code>link.exe</code>.</p>
<pre style="background-color:#282c34;">
<code class="language-dockerfile" data-lang="dockerfile"><span style="color:#dcdfe4;">ENV CARGO_TARGET_X86_64_PC_WINDOWS_MSVC_LINKER=lld-link
</span></code></pre><h3 id="5-profit">5. Profit</h3>
<p>Building a container image from this Dockerfile spec should give allow you to run containers capable of compiling and linking a Rust project targeting Windows, including any C/C++ code that might be used as a dependency....<a href="https://jake-shadle.github.io/xwin/#common-issues">mostly</a>.</p>
<pre style="background-color:#282c34;">
<code class="language-sh" data-lang="sh"><span style="color:#e06c75;">cargo</span><span style="color:#dcdfe4;"> build</span><span style="color:#e06c75;"> --target</span><span style="color:#dcdfe4;"> x86_64-pc-windows-msvc
</span></code></pre><h2 id="bonus-headless-testing">Bonus: Headless testing</h2>
<p>Of course, though compiling and linking a Rust project on Linux is one thing, our CD pipeline also needs to run tests! I've mentioned <code>wine</code> several times so far as a way you could run Windows programs such as the MSVC toolchain under Linux, so naturally, that's what we're going to do with our test executables.</p>
<h3 id="1-install">1. Install</h3>
<p>Debian tends to update packages at a glacial pace, as in the case of <a href="https://www.winehq.org/"><code>wine</code></a> where the <a href="https://www.winehq.org/news/2020111001"><code>5.0.3</code></a> version packaged in <a href="https://packages.debian.org/testing/wine">bullseye</a> is about 9 months out of date. In this case, it actually matters, as some crates, for example <a href="https://github.com/tokio-rs/mio/pull/1505">mio</a>, rely on relatively recent wine releases to implement features or fix bugs. Since mio is a foundational crate in the Rust ecosystem, we'll be installing wine's staging version, which is <a href="https://www.winehq.org/news/2021081301">6.15</a> at the time of this writing.</p>
<pre style="background-color:#282c34;">
<code class="language-dockerfile" data-lang="dockerfile"><span style="color:#dcdfe4;">RUN set -eux; \
    curl --fail https://dl.winehq.org/wine-builds/winehq.key | gpg --dearmor &gt; $KEYRINGS/winehq.gpg; \
    echo &quot;deb [signed-by=$KEYRINGS/winehq.gpg] https://dl.winehq.org/wine-builds/debian/ bullseye main&quot; &gt; /etc/apt/sources.list.d/winehq.list; \
    </span><span style="color:#5c6370;"># The way the debian package works requires that we add x86 support, even
    # though we are only going be running x86_64 executables. We could also
    # build from source, but that is out of scope.
</span><span style="color:#dcdfe4;">    dpkg --add-architecture i386; \
    apt-get update &amp;&amp; apt-get install --no-install-recommends -y winehq-staging; \
    apt-get remove -y --auto-remove; \
    rm -rf /var/lib/apt/lists/*;
</span></code></pre><h3 id="2-specify-runner">2. Specify runner</h3>
<p>By default, <code>cargo</code> will attempt to run test binaries natively, but luckily this behavior is trivial to override by supplying a <a href="https://doc.rust-lang.org/cargo/reference/config.html#targettriplerunner">single</a> environment variable to tell cargo how it should run each test binary. This method is also how you can run tests for <code>wasm32-unknown-unknown</code> locally via a wasm runtime like <a href="https://github.com/bytecodealliance/wasmtime">wasmtime</a>. ðŸ™‚</p>
<pre style="background-color:#282c34;">
<code class="language-dockerfile" data-lang="dockerfile"><span style="color:#dcdfe4;">ENV \
    </span><span style="color:#5c6370;"># wine can be quite spammy with log messages and they&#39;re generally uninteresting
</span><span style="color:#dcdfe4;">    WINEDEBUG=&quot;-all&quot; \
    </span><span style="color:#5c6370;"># Use wine to run test executables
</span><span style="color:#dcdfe4;">    CARGO_TARGET_X86_64_PC_WINDOWS_MSVC_RUNNER=&quot;wine&quot;
</span></code></pre><h3 id="3-test">3. Test</h3>
<p>Now we can compile, link, and test Windows executables with just a standard cargo invocation.</p>
<pre style="background-color:#282c34;">
<code class="language-sh" data-lang="sh"><span style="color:#e06c75;">cargo</span><span style="color:#dcdfe4;"> test</span><span style="color:#e06c75;"> --target</span><span style="color:#dcdfe4;"> x86_64-pc-windows-msvc
</span></code></pre><h2 id="final-image-definition">Final image definition</h2>
<p>Putting it all together, here is an image definition that should allow you to cross compile to Windows and run headless tests, without needing a Windows install at any step.</p>
<pre style="background-color:#282c34;">
<code class="language-dockerfile" data-lang="dockerfile"><span style="color:#5c6370;"># We&#39;ll just use the official Rust image rather than build our own from scratch
</span><span style="color:#c678dd;">FROM</span><span style="color:#dcdfe4;"> docker.io/library/rust:1.54.0-slim-bullseye

</span><span style="color:#c678dd;">ENV </span><span style="color:#dcdfe4;">KEYRINGS /usr/local/share/keyrings

</span><span style="color:#c678dd;">RUN </span><span style="color:#dcdfe4;">set -eux; \
    mkdir -p $KEYRINGS; \
    apt-get update &amp;&amp; apt-get install -y gpg curl; \
    </span><span style="color:#5c6370;"># clang/lld/llvm
</span><span style="color:#dcdfe4;">    curl --fail https://apt.llvm.org/llvm-snapshot.gpg.key | gpg --dearmor &gt; $KEYRINGS/llvm.gpg; \
    </span><span style="color:#5c6370;"># wine
</span><span style="color:#dcdfe4;">    curl --fail https://dl.winehq.org/wine-builds/winehq.key | gpg --dearmor &gt; $KEYRINGS/winehq.gpg; \
    echo &quot;deb [signed-by=$KEYRINGS/llvm.gpg] http://apt.llvm.org/bullseye/ llvm-toolchain-bullseye-13 main&quot; &gt; /etc/apt/sources.list.d/llvm.list; \
    echo &quot;deb [signed-by=$KEYRINGS/winehq.gpg] https://dl.winehq.org/wine-builds/debian/ bullseye main&quot; &gt; /etc/apt/sources.list.d/winehq.list;

</span><span style="color:#c678dd;">RUN </span><span style="color:#dcdfe4;">set -eux; \
    dpkg --add-architecture i386; \
    </span><span style="color:#5c6370;"># Skipping all of the &quot;recommended&quot; cruft reduces total images size by ~300MiB
</span><span style="color:#dcdfe4;">    apt-get update &amp;&amp; apt-get install --no-install-recommends -y \
        clang-13 \
        </span><span style="color:#5c6370;"># llvm-ar
</span><span style="color:#dcdfe4;">        llvm-13 \
        lld-13 \
        </span><span style="color:#5c6370;"># get a recent wine so we can run tests
</span><span style="color:#dcdfe4;">        winehq-staging \
        </span><span style="color:#5c6370;"># Unpack xwin
</span><span style="color:#dcdfe4;">        tar; \
    </span><span style="color:#5c6370;"># ensure that clang/clang++ are callable directly
</span><span style="color:#dcdfe4;">    ln -s clang-13 /usr/bin/clang &amp;&amp; ln -s clang /usr/bin/clang++ &amp;&amp; ln -s lld-13 /usr/bin/ld.lld; \
    </span><span style="color:#5c6370;"># We also need to setup symlinks ourselves for the MSVC shims because they aren&#39;t in the debian packages
</span><span style="color:#dcdfe4;">    ln -s clang-13 /usr/bin/clang-cl &amp;&amp; ln -s llvm-ar-13 /usr/bin/llvm-lib &amp;&amp; ln -s lld-link-13 /usr/bin/lld-link; \
    </span><span style="color:#5c6370;"># Verify the symlinks are correct
</span><span style="color:#dcdfe4;">    clang++ -v; \
    ld.lld -v; \
    </span><span style="color:#5c6370;"># Doesn&#39;t have an actual -v/--version flag, but it still exits with 0
</span><span style="color:#dcdfe4;">    llvm-lib -v; \
    clang-cl -v; \
    lld-link --version; \
    </span><span style="color:#5c6370;"># Use clang instead of gcc when compiling binaries targeting the host (eg proc macros, build files)
</span><span style="color:#dcdfe4;">    update-alternatives --install /usr/bin/cc cc /usr/bin/clang 100; \
    update-alternatives --install /usr/bin/c++ c++ /usr/bin/clang++ 100; \
    apt-get remove -y --auto-remove; \
    rm -rf /var/lib/apt/lists/*;

</span><span style="color:#5c6370;"># Retrieve the std lib for the target
</span><span style="color:#c678dd;">RUN </span><span style="color:#dcdfe4;">rustup target add x86_64-pc-windows-msvc

</span><span style="color:#c678dd;">RUN </span><span style="color:#dcdfe4;">set -eux; \
    xwin_version=&quot;0.1.1&quot;; \
    xwin_prefix=&quot;xwin-$xwin_version-x86_64-unknown-linux-musl&quot;; \
    </span><span style="color:#5c6370;"># Install xwin to cargo/bin via github release. Note you could also just use `cargo install xwin`.
</span><span style="color:#dcdfe4;">    curl --fail -L https://github.com/Jake-Shadle/xwin/releases/download/$xwin_version/$xwin_prefix.tar.gz | tar -xzv -C /usr/local/cargo/bin --strip-components=1 $xwin_prefix/xwin; \
    </span><span style="color:#5c6370;"># Splat the CRT and SDK files to /xwin/crt and /xwin/sdk respectively
</span><span style="color:#dcdfe4;">    xwin --accept-license 1 splat --output /xwin; \
    </span><span style="color:#5c6370;"># Remove unneeded files to reduce image size
</span><span style="color:#dcdfe4;">    rm -rf .xwin-cache /usr/local/cargo/bin/xwin;

</span><span style="color:#5c6370;"># Note that we&#39;re using the full target triple for each variable instead of the
# simple CC/CXX/AR shorthands to avoid issues when compiling any C/C++ code for
# build dependencies that need to compile and execute in the host environment
</span><span style="color:#c678dd;">ENV </span><span style="color:#dcdfe4;">CC_x86_64_pc_windows_msvc=</span><span style="color:#98c379;">&quot;clang-cl&quot;</span><span style="color:#dcdfe4;"> \
    CXX_x86_64_pc_windows_msvc=&quot;clang-cl&quot; \
    AR_x86_64_pc_windows_msvc=&quot;llvm-lib&quot; \
    </span><span style="color:#5c6370;"># wine can be quite spammy with log messages and they&#39;re generally uninteresting
</span><span style="color:#dcdfe4;">    WINEDEBUG=&quot;-all&quot; \
    </span><span style="color:#5c6370;"># Use wine to run test executables
</span><span style="color:#dcdfe4;">    CARGO_TARGET_X86_64_PC_WINDOWS_MSVC_RUNNER=&quot;wine&quot; \
    </span><span style="color:#5c6370;"># Note that we only disable unused-command-line-argument here since clang-cl
    # doesn&#39;t implement all of the options supported by cl, but the ones it doesn&#39;t
    # are _generally_ not interesting.
</span><span style="color:#dcdfe4;">    CL_FLAGS=&quot;-Wno-unused-command-line-argument -fuse-ld=lld-link /imsvc/xwin/crt/include /imsvc/xwin/sdk/include/ucrt /imsvc/xwin/sdk/include/um /imsvc/xwin/sdk/include/shared&quot; \
    </span><span style="color:#5c6370;"># Let cargo know what linker to invoke if you haven&#39;t already specified it
    # in a .cargo/config.toml file
</span><span style="color:#dcdfe4;">    CARGO_TARGET_X86_64_PC_WINDOWS_MSVC_LINKER=&quot;lld-link&quot; \
    RUSTFLAGS=&quot;-Lnative=/xwin/crt/lib/x86_64 -Lnative=/xwin/sdk/lib/um/x86_64 -Lnative=/xwin/sdk/lib/ucrt/x86_64&quot;

</span><span style="color:#5c6370;"># These are separate since docker/podman won&#39;t transform environment variables defined in the same ENV block
</span><span style="color:#c678dd;">ENV </span><span style="color:#dcdfe4;">CFLAGS_x86_64_pc_windows_msvc=</span><span style="color:#98c379;">&quot;$CL_FLAGS&quot;</span><span style="color:#dcdfe4;"> \
    CXXFLAGS_x86_64_pc_windows_msvc=&quot;$CL_FLAGS&quot;

</span><span style="color:#5c6370;"># Run wineboot just to setup the default WINEPREFIX so we don&#39;t do it every
# container run
</span><span style="color:#c678dd;">RUN </span><span style="color:#dcdfe4;">wine wineboot --init
</span></code></pre>
<p>Here is a <a href="https://gist.github.com/Jake-Shadle/542dfa000a37c4d3c216c976e0fbb973">gist</a> with the same dockerfile, and an example of how you can build it. I'm using <code>podman</code> here, but <code>docker</code> should also work.</p>
<pre style="background-color:#282c34;">
<code class="language-sh" data-lang="sh"><span style="color:#e06c75;">curl --fail -L -o</span><span style="color:#dcdfe4;"> xwin.dockerfile https://gist.githubusercontent.com/Jake-Shadle/542dfa000a37c4d3c216c976e0fbb973/raw/bf6cff2bd4ad776d3def8520adb5a5c657140a9f/xwin.dockerfile
</span><span style="color:#e06c75;">podman -t</span><span style="color:#dcdfe4;"> xwin</span><span style="color:#e06c75;"> -f</span><span style="color:#dcdfe4;"> xwin.dockerfile .
</span></code></pre><h2 id="common-issues">Common issues</h2>
<p>Unfortunately, everything is not sunshine and unicorns where cross compiling is concerned, but all of them are solvable, at least in principle.</p>
<h3 id="cmake">CMake</h3>
<p>It's not exactly a secret that I am <a href="https://twitter.com/Ca1ne/status/1426102744578940929">not a fan</a> of CMake. Inexplicably (to me at least), CMake has become the default way to configure and build open source C/C++ code. As I basically only use Rust now, this would normally not bother me, however, many Rust crates still wrap C/C++ libraries, and due to the ubiquitous nature of CMake, a significant minority  of those crates just directly use <a href="https://github.com/alexcrichton/cmake-rs"><code>cmake</code></a> (or worse, direct invocation) to let CMake drive the building of the underlying C/C++ code. This is <del>great</del> excusable when it works, however, in my experience, CMake scripts tend to be a house of cards that falls down at the slightest deviation from the &quot;one true path&quot; intended by the author(s) of the CMake scripts and cross compiling to Windows is a big deviation that not only knocks down the cards but also sets them on fire.</p>
<p>The simplest and most effective solution to CMake issues is to <a href="https://github.com/EmbarkStudios/physx-rs/pull/59">replace it with cc</a>. In some cases like Physx or <a href="https://github.com/EmbarkStudios/rust-gpu/pull/179">spirv-tools</a> that can be a fair amount of work, but in many <a href="https://github.com/purpleprotocol/mimalloc_rust/pull/58">cases</a> it's not much. The benefits of course extend beyond just making cross compilation easier, it also gets rid of the CMake installation dependency, as well as just making it easier for outside contributors to understand how the C/C++ code is built, since they don't need to actually crawl through some project's CMake scripts trying to figure out what the hell is going on, they can just look at the build.rs file instead.</p>
<h3 id="masm">MASM</h3>
<p>Unfortunately, we don't need to worry about just Rust, C, and C++ in some Rust projects, there are also a small number of crates here and there which also use assembly. While in the future this will be able to be handled <a href="https://blog.rust-lang.org/inside-rust/2020/06/08/new-inline-asm.html">natively</a> in rustc, we have to deal with the present, and unfortunately the present contains <a href="https://en.wikipedia.org/wiki/Comparison_of_assemblers#x86-64_assemblers">multiple assemblers with incompatible syntax</a>. In the Microsoft toolchain, <code>ml64.exe</code> assembles <a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">MASM</a>, and while there are <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=762167">ongoing</a> <a href="https://groups.google.com/g/llvm-dev/c/AXk5_ECZVIo/m/MrFxPynAAQAJ">efforts</a> to get LLVM to assemble MASM via llvm-ml, the fact that the <a href="https://lists.llvm.org/pipermail/llvm-dev/2020-October/146015.html">last update</a> I can find is from October 2020, and there is no project page for llvm-ml like there for <a href="https://llvm.org/docs/CommandGuide/index.html">other</a> llvm tools, tells me I might be wasting my time trying to get it to work for all assembly that we need to compile.</p>
<p>Luckily, there is a fairly easy workaround for this gap until llvm-ml becomes more mature. Even though we aren't targeting <code>x86_64-pc-windows-gnu</code> for the reasons stated above, the few projects that we use that use assembly generally do have both a MASM version as well as a <a href="https://en.wikipedia.org/wiki/GNU_Assembler">GAS</a> version so that people who want to can target <code>x86_64-pc-windows-gnu</code>. However, since cross compilation to Windows from a non-Windows platform is fairly rare, you'll often need to provide <a href="https://github.com/sonos/tract/pull/339">PRs</a> to projects to fix up assumptions made about the target and host being the same. And unfortunately, this niche case also comes with a bit of maintenance burden that maintainers of a project might be uncomfortable with taking since <a href="https://github.com/BLAKE3-team/BLAKE3/pull/101">they can't easily provide coverage</a>, which is a totally fair reason to not merge such a PR.</p>
<h3 id="compiler-target-confusion">Compiler Target Confusion</h3>
<p>This one is the rarest of all, at least anecdotally, as I only encountered this kind of issue in Physx. Basically, the issue boils down to a project assuming that Windows == MSVC toolchain and Clang != Windows, which can result in (typically) preprocessor logic errors.</p>
<p>For example, here we have a clang specific warning being disabled for a single function, except it's fenched by both using clang as the compiler as well as targeting Linux, which means targeting Windows won't disable the warning, and if warnings are treated as errors, we'll get a compile failure.</p>
<pre style="background-color:#282c34;">
<code class="language-diff" data-lang="diff"><span style="color:#dcdfe4;">@see PxCreateFoundation()
*/
#if PX_CLANG
</span><span style="color:#e06c75;">-#if PX_LINUX
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored &quot;-Wreturn-type-c-linkage&quot;
-#endif // PX_LINUX
</span><span style="color:#98c379;">+    #pragma clang diagnostic push
+    #pragma clang diagnostic ignored &quot;-Wreturn-type-c-linkage&quot;
</span><span style="color:#dcdfe4;">#endif // PX_CLANG
PX_C_EXPORT PX_FOUNDATION_API physx::PxFoundation&amp; PX_CALL_CONV PxGetFoundation();
#if PX_CLANG
</span><span style="color:#e06c75;">-#if PX_LINUX
-#pragma clang diagnostic pop
-#endif // PX_LINUX
</span><span style="color:#98c379;">+    #pragma clang diagnostic pop
</span><span style="color:#dcdfe4;">#endif // PX_CLANG

namespace physx
</span></code></pre>
<p>For the most part these kinds of problems won't occur since <code>clang-cl</code> very effectively masquerades as cl, including setting predefined macros like <a href="https://clang.llvm.org/docs/UsersManual.html#microsoft-extensions"><code>_MSC_VER</code></a> and others so that a vast majority if C/C++ code that targets Windows &quot;just works&quot;.</p>
<h2 id="conclusion">Conclusion</h2>
<p>And there you have it, a practical summary on how to cross compile Rust projects for <code>x86_64-pc-windows</code> from a Linux host or container, I hope you've found at least some of this information useful!</p>
<p>As for next steps, my team is rapidly improving our renderer built on top of Vulkan and <a href="https://github.com/EmbarkStudios/rust-gpu">rust-gpu</a>, but our non-software rasterization testing is mostly limited to a few basic tests on our Mac VMs since they are the only ones with GPUs. While I am curious about getting rendering tests working for Windows under wine, I am also quite hesitant. While wine and <a href="https://github.com/ValveSoftware/Proton">Proton</a> have been making big steps and support a large amount of Windows games, we are using fairly bleeding edge parts of Vulkan like ray tracing, and running rendering tests on Linux means you're now running on top of the Linux GPU drivers rather than the Windows ones, making test results fairly suspect on whether they are actually detecting issues that might be present in a native Windows environment. It could still be fun though!</p>
<p>While it might seem like I hate Windows due to the content of this post, that's very much not the case. I am comfortable in Windows having used it for 20+ years or so both personally and professionally, I just prefer Linux these days, especially for automated infrastructure like CD which this post is geared towards...</p>
<p>..however, the same cannot be said for Apple/Macs, as I do <a href="https://twitter.com/Ca1ne/status/1350143769589518337">hate</a> <a href="https://twitter.com/Ca1ne/status/1367428039613767682">them</a> <a href="https://twitter.com/Ca1ne/status/1387068353303416834">with</a> the <a href="https://twitter.com/Ca1ne/status/1387755158919127049">fiery</a> <a href="https://twitter.com/Ca1ne/status/1389889700652068865">passion</a> of a <a href="https://twitter.com/Ca1ne/status/1389905675405385733">thousand</a> <a href="https://twitter.com/Ca1ne/status/1401998662566354946">suns</a>. Maintaining &quot;automated&quot; Mac machines is one of the most deeply unpleasant experiences of my career, one I wouldn't wish on my worst enemy, but since Macs are one of our primary targets (thankfully iOS is off the table due to &quot;reasons&quot;), we do need to build and test it along with our other targets. So maybe cross compiling to Macs will be in a future post. ðŸ˜…</p>

                            </div>
                        </div>
                        
                        
<footer class="card-footer">
    <div class="article-footer">
        <div class="columns is-multiline">
            <div class="column is-12">
                <p>
                    Published
                    

<time datetime="2021-08-22">
    2021-08-22
</time>


                    


                    


in <a href="https://jake-shadle.github.io/categories/code/">
    <span class="tag is-success">
        code
    </span>
</a>


                    

and tagged

<a href="https://jake-shadle.github.io/tags/linux/">
    <span class="tag is-link">linux </span>
</a>



,




<a href="https://jake-shadle.github.io/tags/windows/">
    <span class="tag is-link">windows </span>
</a>



and




<a href="https://jake-shadle.github.io/tags/rust/">
    <span class="tag is-link">rust </span>
</a>






                </p>
            </div>
            <div class="column">
                <a class="button is-pulled-right is-info" href="/">Back Home</a>
            </div>
        </div>
    </div>
</footer>

                        
                    </div>
                </article>
            </div>
        </div>
    </section>
</main>

    
    


    

    <script type="text/javascript" src="https:&#x2F;&#x2F;jake-shadle.github.io&#x2F;js&#x2F;zulma_navbar.js"></script>

    

    
</body>

</html>